        - # overloard parse for the CircuitFile type
        - # used to parse LTspice circuit files *.asc
        - 
        - import Base: parse, show
        - import Base: haskey, keys, values
        - import Base: getindex, setindex!, endof
        - import Base: start, next, done, length, eltype
        - 
        - #export CircuitFile, getcircuitpath, getmeasurmentnames, getstepnames
        - #export isneedsupdate
        - 
        - ### BEGIN Type CircuitFile and constructors ###
        - 
        - type CircuitFile
        5 	circuitpath			:: ASCIIString
        - 	circuitfilearray:: Array{ASCIIString,1}    # text of circuit file
        - #	parameters 			:: Dict{ASCIIString,Tuple{Float64,Float64,Int}} # dictionay of parameters (value, multiplier, index)
        -   parameternames  :: Array{ASCIIString,1}
        -   parameters      :: Array{Tuple{Float64,Float64,Int},1}  # array of parameters (value, multiplier, index)
        -   measurementnames:: Array{ASCIIString,1}              # measurment names
        -   stepnames			  :: Array{ASCIIString,1}  
        -   needsupdate			:: Bool # true if any parameter has been changed
        - end
        - 
        - ### END Type CircuitFile and constructors ###
        - 
        - ### BEGIN overloading Base ###
        - 
        - function show(io::IO, x::CircuitFile)
        2 	println(io,x.circuitpath)
        2   if length(x.parameters)>0
        2   	println(io,"")
        2   	println(io,"Parameters")
        2   	for (key,(value,m,i)) in zip(x.parameternames,x.parameters)
        4     	println(io,"  $(rpad(key,25,' ')) = $value")
        -   	end
        -   end
        2  	if length(x.measurementnames)>0 
        2  		println(io,"")
        2  		println(io,"Measurments")
        2  	  for name in x.measurementnames
        2  		 println(io,"  $name")
        -  	  end
        -   end
        2  	if length(x.stepnames)>0
        0  		println(io,"")
        0  		println(io,"Sweeps")
        0  	  for name in x.stepnames
        0  		 println(io,"  $name")
        -  	  end
        -   end
        - end
        - 
        - # CircuitFile is a Dict of its parameters
        - #haskey(x::CircuitFile,key::ASCIIString) = haskey(x.parameters,key::ASCIIString)
       13 haskey(x::CircuitFile,key::ASCIIString) = findfirst(x.parameternames, key) != 0
        - #keys(x::CircuitFile) = keys(x.parameters)
        1 keys(x::CircuitFile) = [key for key in x.parameternames]
        - 
        - #=
        - function values(x::CircuitFile)
        -   result = Array(Float64,0)
        -   for (key,(value,m,i)) in x.parameters
        -     push!(result,value)
        -   end
        -   return result
        - end
        - =#
        - 
        1 values(x::CircuitFile) = [parameter[1] for parameter in x.parameters]
        - 
        - #=
        - function getindex(x::CircuitFile, key::ASCIIString)
        -   (v,m,i) =  x.parameters[key]  # just want the value.  Hide internal stuff
        -   return v
        - end
        - =#
        - 
        - function getindex(x::CircuitFile, key::ASCIIString)
        8   k = findfirst(x.parameternames, key)
        8   if k == 0 
        0     throw(KeyError(key))
        -   else
        8     return x.parameters[k][1]
        -   end
        - end
        - 
        - #=
        - function setindex!(x::CircuitFile, value:: Float64, key:: ASCIIString)
        -   (v,m,i) = x.parameters[key]
        -   x.parameters[key] = (value,m,i)
        -   x.circuitfilearray[i] = "$(value/m)"
        -   x.needsupdate = true
        - end
        - =#
        - 
        - function setindex!(x::CircuitFile, value:: Float64, key:: ASCIIString)
        -   k = findfirst(x.parameternames, key)
        -   if k == 0 
        -     throw(KeyError(key))
        -   else
        -     (v,m,i) = x.parameters[k]
        -     x.parameters[k] = (value,m,i)
        -     x.circuitfilearray[i] = "$(value/m)"
        -     x.needsupdate = true
        -   end
        - end
        - 
        1 length(x::CircuitFile) = length(x.parameters)
        1 eltype(::CircuitFile) = Float64
        - 
        - # CircuitFile iterates over its parameters
        - #=
        - start(x::CircuitFile) = start(x.parameters)
        - function next(x::CircuitFile, state)
        -   ((key,(value,m,i)),state) = next(x.parameters, state)
        -   return ((key=>value),state)
        - end
        - done(x::CircuitFile, state) = done(x.parameters, state)
        - =#
        2 start(x::CircuitFile) = 0
        - function next(x::CircuitFile, state)
        4   state +=1
        4   return ((x.parameternames[state]=>x.parameters[state][1]),state)
        - end
        6 done(x::CircuitFile, state) = ~(state < length(x.parameters))
        - 
        - function parse(::Type{CircuitFile}, circuitpath::ASCIIString)
        -   #= reads circuit file and returns a tuple of
        -   Dict of parameters
        -   Dict of measurements, values N/A
        -   circuit file array
        -     The circuit file array is an array of strings which when concatenated
        -     produce the circuit file.  The elements of the array split the file 
        -     around parameter values to avoid parsing the file every time a parameter
        -     is modified
        -   =#
        5   ltspicefile = readall(circuitpath)            # read the circuit file
        -   # create empty dictionarys to be filled as file is parsed
        -   #key = parameter, value = (parameter value, multiplier, circuit file array index)
        - #  parameters = Dict{ASCIIString,Tuple{Float64,Float64,Int}}() 
        5   parameternames = Array(ASCIIString,0)
        5   parameters = Array(Tuple{Float64,Float64,Int},0)
        5   measurementnames = Array(ASCIIString,0)
        5   stepnames	= Array(ASCIIString,0)
        5   circuitfilearray = Array(ASCIIString,1)
        5   circuitfilearray[1] = ""
        -   # regex used to parse file.  I know this is a bad comment.
        5   match_tags = r"""(
        -                 ^TEXT .*?(!|;)|
        -                 [.](param)[ ]+([A-Za-z0-9]*)[= ]*([0-9.eE+-]*)([a-z]*)|
        -                 [.](measure|meas)[ ]+(?:ac|dc|op|tran|tf|noise)[ ]+(\w+)[ ]+|
        -                 [.](step)[ ]+(oct |param ){0,1}[ ]*
        -                 (\w+)[ ]+(?:list ){0,1}[ ]*[0-9.e+-]+[a-z]*[ ]+|
        -                 [.](step)[ ]+(\w+)[ ]+(\w+[(]\w+[)])[ ]+
        -                 )"""imx
        - 
        -   # parse the file
        5   directive = false   # true for directives, false for comments
        5   m = match(match_tags,ltspicefile)
        5   i = 1  # index for circuit file array
        5   position = 1   # pointer into ltspicefile
        5   old_position = 1
        5   while m!=nothing
       61     commentordirective = m.captures[2] # ";" starts a comment, "!" starts a directive
       61     isparamater = m.captures[3]!=nothing  # true for parameter card
       61     parametername = m.captures[4]
       61     parametervalue = m.captures[5]
       61     parameterunit = m.captures[6]
       61     ismeasure = m.captures[7]!=nothing   # true for measurement card
       61     measurementname = m.captures[8] # name in .log
       61     isstep = m.captures[9]!=nothing
       61     oct_or_param_or_nothing = m.captures[10]
       61     steppedname = m.captures[11] # name in .log
       61     issteppedmodel = m.captures[12]!=nothing
       61     modeltype = m.captures[13] # for example NPN
       61     modelname = m.captures[14] # name in .log
        - 
        -     # determine if we are processign a comment or directive
       61     if commentordirective == "!"
       25       directive = true
       36     elseif commentordirective == ";"
        2       directive = false
        -     end
       61     if directive
       56       if isparamater  # this is a paramater card
       22         if haskey(units,parameterunit) # if their is an SI unit
        8           multiplier = units[parameterunit] # find the multiplier
        -         else
       14           multiplier = 1.0 # if no unit, multiplier is 1.0
        -         end
       22         valuenounit = try  # try to convert the value.  might just want to let the exception happen...
       22           parse(Float64,parametervalue)
        -         catch
        -           convert(Float64,NaN)
        -         end
       22         old_position = position
       22         position = m.offsets[5]   # offset of the begining if the value in the circuit file
       22         circuitfilearray = vcat(circuitfilearray,ltspicefile[old_position:position-1])  # text before the value
       22         i += 1
       22         circuitfilearray = vcat(circuitfilearray,ltspicefile[position:position+length(parametervalue)-1])  # text of the value
       22         i += 1
        -         # parameters[parametername] = (valuenounit * multiplier, multiplier, i)
       22         push!(parameternames, parametername)
       22         push!(parameters, (valuenounit * multiplier, multiplier, i))
       22         position = position+length(parametervalue)
       34       elseif ismeasure  # this is a measurement card
        9         push!(measurementnames,lowercase(measurementname)) # measurements are all lower case in log file
       25       elseif isstep # this is a step card
        0         push!(stepnames,lowercase(steppedname)) # measurements are all lower case in log file
       25       elseif issteppedmodel
        0         push!(stepnames,lowercase(modelname)) # measurements are all lower case in log file
        -       end
        -     end
       61     m = match(match_tags,ltspicefile,m.offset+length(m.match))   # find next match
        -   end
        5   circuitfilearray = vcat(circuitfilearray,ltspicefile[position:end])  # the rest of the circuit
        5   return CircuitFile(circuitpath, circuitfilearray, parameternames, parameters,
        -                      measurementnames, stepnames, false)
        - end
        - 
        - ### END overloading Base ###
        - 
        - ### BEGIN CircuitFile specific methods ###
        - 
        - "writes circuit file back to disk if any parameters have changed"
        - function update!(x::CircuitFile)
        2 	if x.needsupdate
        0 		io = open(x.circuitpath,false,true,false,false,false)  # open circuit file to be overwritten
        0   		for text in x.circuitfilearray
        0     		print(io,text)
        -   		end
        0   		close(io)
        0   		x.needsupdate = false
        -   	end
        2   	return nothing
        - end
        - 
        3 getcircuitpath(x::CircuitFile) = x.circuitpath
        - #=
        - function getparameters(x::CircuitFile)
        -   result = Dict{ASCIIString,Float64}()
        -   [result[y] = x.parameters[y][1] for y in keys(x.parameters)]
        -   return result
        - end
        - =#
        1 getparameternames(x::CircuitFile) = x.parameternames
        3 getparameters(x::CircuitFile) = [parameter[1] for parameter in x.parameters]
       19 getmeasurementnames(x::CircuitFile) = x.measurementnames
        2 getstepnames(x::CircuitFile) = x.stepnames
        7 isstep(x::CircuitFile) = length(x.stepnames) != 0
        2 hasmeasurements(x::CircuitFile) = length(x.measurementnames) != 0
        - 
        - ### END CircuitFile specific methods ###
        - 
        - ### Begin other ###
        - 
        - # units as defined in LTspice
        - units = Dict()
        - units["K"] = 1.0e3
        - units["k"] = 1.0e3
        - units["MEG"] = 1.0e6
        - units["meg"] = 1.0e6
        - units["G"] = 1.0e9
        - units["g"] = 1.0e9
        - units["T"] = 1.0e12
        - units["t"] = 1.0e12
        - units["M"] = 1.0e-3
        - units["m"] = 1.0e-3
        - units["U"] = 1.0e-6
        - units["u"] = 1.0e-6
        - units["N"] = 1.0e-9
        - units["n"] = 1.0e-9
        - units["P"] = 1.0e-12
        - units["p"] = 1.0e-12
        - units["F"] = 1.0e-15
        - units["f"] = 1.0e-15
        - 
        - ### END other ###
